## 数1的个数
给定一个十进制正整数n（1<=n<=10000），写下从1到n的所有整数，然后数一下其中出现的数字“1”的个数。
例如当n=2时，写下1，2.这样只出现了1个“1”；当n=12时，写下1，2，3，4，5，6，7，8，9，10，11，12。这样出现了5个“1”。
### 输入
有多组输入，每组输入占一行。每一行有一个数字n。
### 输出
对于每组输入，输出一行，每行一个正整数，即“1”的个数。
### 样例
#### 样例输入
2
12
#### 样例输出
1
5
### 思路
将每一个小于等于n的数字遍历过去，每一个数字进行拆分得到其中的“1”的个数，累加起来
```cpp
#include<stdio.h>
int main()
{
    int n,i,sum;
    while (scanf("%d",&n)!=EOF)
    {
        sum=0;
        for (i=1; i<=n; i++)//遍历小于等于n的所有数
        {
            int temp=i;
            int onenumbers=0;
            while (temp)//拆分
            {
                if (temp%10==1)
                {
                    onenumbers++;
                }
                temp/=10;
            }
            sum+=onenumbers;
        }
        printf("%d\n",sum);
    }
    return 0;
}
```
### 问题
无论是100还是200，这两组数据都需要计算100以内的数字的“1”的个数，而且过程完全相同。
如果我们先输入1000，然后再输入200。实际上，200这个数据早就被计算过了，而这个代码却会去重复计算，浪费时间+内存+电量。
题目要求的数据范围不大，只有1-10000个数字，每一个数字有对应的一个唯一确定的输出。
### 改进->打表法
```cpp
#include<stdio.h>

int main()
{
	int f[10010];//这里保存了所有可能的结果
    int n,i,sum=0;
    for (i=1; i<=10000; i++)//遍历小于等于n的所有数
    {
    	int temp=i;
        int onenumbers=0;
        while (temp)//拆分
        {
            if (temp%10==1)
            {
                onenumbers++;
            }
            temp/=10;
        }
        sum+=onenumbers;
        f[i]=sum;
    }
    while (scanf("%d",&n)!=EOF)
    {
        printf("%d\n",f[n]);
    }
    return 0;
}
```